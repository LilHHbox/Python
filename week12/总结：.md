深度优先搜索：（树的前序，中序，后序遍历都是深度优先）

如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。

 

#### 判断两棵树是否相同

如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。

广度优先搜索：（树的层次遍历）

 

^：按位异或，

if (not a) ^ (not b):

  print('true')

只有a和b不同的时候才返回true，即a和b一个为空，另一个不为空的时候

 

&与

|或

^同或

~按位取反



#### 二叉树的最大深度

深度优先：

在写递归的时候，通常情况下不用定义全局变量，只需要return 递归函数+对应值 即可解决

广度优先：

类似于广度优先搜索，不同的是每一次队列不仅是拿出一个节点，而是拿出该层所有节点，然后定义变量等于循环次数

 

#### 将有序数组转换为二叉搜索树

二叉搜索树的特征是左子树所有节点的值小于根节点，右子树的所有结点的值大于根节点，同时题目要求任何一个节点的左右儿子高度相差小于等于1。

由此可知，一棵树的子树同样要满足以上特点，所以用递归解法

 

#### 平衡二叉树

根据108递归的思想，一棵树是平衡二叉树的前提是当且仅当所有树都为平衡二叉树，所以使用递归。



#### 二叉树的中序遍历

递归法：

刷leecode递归函数因为全局变量等因素，不好写的时候可以在大函数内部构造一个小函数，而中序遍历最简单的方式就是递归操作：

inorder(root.left)

res.append(root.val)

inorder(root.right)

迭代法：

迭代法就是通过显式的构造递归函数所用到的栈

while len(se)>0 or node!=None:

while node!=None:#迭代法：相当于显式的构造一个栈

se.append(node)

node=node.left

node=se.pop()

res.append(node.val)

node=node.right