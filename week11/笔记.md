67.二进制加法

 print('{0:b}'.format(int(a, 2) + int(b, 2)))#字符串a是2进制，int(a,2)指的是转化为10进制；两个相加再转化为二进制；b代表二进制

 

 

70.爬楼梯

 

动态规划：

将递归算法重新携程非递归算法，让后者把那些子问题的答案系统的记录在一个表（数组）内。

（1）：定义数组含义

（2）：找出数组元素之间的关系式（类似于递推关系）

（3）：找出初始条件（仔细慎重）

 

我们用 f(x)f(x) 表示爬到第 xx 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：

f(x) = f(x - 1) + f(x - 2)

它意味着爬到第 x 级台阶的方案数是爬到第 x−1 级台阶的方案数和爬到第 x - 2 级台阶的方案数的和。很好理解，因为每次只能爬 1 级或 2 级，所以 f(x) 只能从 f(x - 1)) 和 f(x - 2)转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。

 

 

还有一道题：

最大子序列和：

假设nums 数组的长度是n ，下标从 0 到 n-1。

我们用 f(i)代表以第 i个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是求出f(i)

 

因此我们只需要求出每个位置的 f(i)，然后返回数组中的最大值即可。那么我们如何求f(i)呢？我们可以考虑nums[i]单独成为一段还是加入f(i-1)对应的那一段，这取决于f(i-1)和nums[i]的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：

 

f(i)=max{f(i−1)+nums[i],nums[i]}

具体算法就是：如果前一个元素大于零，则把前一个元素加到当前元素上

 

 

71.二叉树的中序遍历

递归法：

刷leecode递归函数因为全局变量等因素，不好写的时候可以在大函数内部构造一个小函数，而中序遍历最简单的方式就是递归操作：

inorder(root.left)

res.append(root.val)

inorder(root.right)

迭代法：

迭代法就是通过显式的构造递归函数所用到的栈

while len(se)>0 or node!=None:

while node!=None:#迭代法：相当于显式的构造一个栈

se.append(node)

node=node.left

node=se.pop()

res.append(node.val)

node=node.right

 

100.判断两棵树是否相同：

深度优先搜索：

如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。

 

如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。